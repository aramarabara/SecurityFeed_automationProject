import fs from 'fs';
import { VulnerabilityAnalyzer } from '../services/scanner/vulnerabilityAnalyzer';
import { GitHubRepository, CodeQLVulnerability } from '../models/vulnerability';
import dotenv from 'dotenv';

// Initialize environment
dotenv.config();

// Test state
const report = {
  lastRun: new Date().toISOString(),
  status: 'PENDING',
  steps: {
    envCheck: { status: 'PENDING', message: '' },
    analyzerInit: { status: 'PENDING', message: '' },
    mockDataCreation: { status: 'PENDING', message: '' },
    vulnerabilityAnalysis: { status: 'PENDING', message: '' },
    reportValidation: { status: 'PENDING', message: '' }
  },
  errors: []
};

function saveReport() {
  const STATUS_FILE = 'public/vulnerability_analyzer_test_status.json';
  
  // Ensure public dir exists
  if (!fs.existsSync('public')) fs.mkdirSync('public');
  fs.writeFileSync(STATUS_FILE, JSON.stringify(report, null, 2));
  console.log(`üìù Report saved to ${STATUS_FILE}`);
}

// Create mock repository data
function createMockRepository(): GitHubRepository {
  return {
    id: '123456789',
    name: 'test-auth-library',
    fullName: 'testuser/test-auth-library',
    stars: 500,
    language: 'TypeScript',
    url: 'https://github.com/testuser/test-auth-library',
    description: 'A test authentication library for testing vulnerability analysis',
    keywords: ['authentication', 'security', 'crypto'],
    createdAt: '2020-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z',
    cloneUrl: 'https://github.com/testuser/test-auth-library.git',
  };
}

// Create mock vulnerability data
function createMockVulnerabilities(): CodeQLVulnerability[] {
  return [
    {
      id: 'vuln-1',
      ruleId: 'js/sql-injection',
      message: 'Potential SQL injection vulnerability in user input',
      severity: 'error',
      filePath: 'src/api/user.js',
      startLine: 42,
      endLine: 45,
      codeSnippet: `const query = "SELECT * FROM users WHERE id = " + userId;`,
      queryName: 'SQL Injection',
      cwe: 'CWE-89',
    },
    {
      id: 'vuln-2',
      ruleId: 'js/hardcoded-credentials',
      message: 'Hardcoded credentials detected in configuration file',
      severity: 'warning',
      filePath: 'config/database.js',
      startLine: 15,
      endLine: 15,
      codeSnippet: `const password = "admin123";`,
      queryName: 'Hardcoded Credentials',
      cwe: 'CWE-798',
    },
    {
      id: 'vuln-3',
      ruleId: 'js/xss',
      message: 'Potential XSS vulnerability in user-generated content',
      severity: 'warning',
      filePath: 'src/components/Comment.jsx',
      startLine: 28,
      endLine: 30,
      codeSnippet: `<div dangerouslySetInnerHTML={{ __html: userComment }} />`,
      queryName: 'Cross-site Scripting',
      cwe: 'CWE-79',
    },
  ];
}

async function runTest() {
  console.log("üß™ Starting Vulnerability Analyzer Unit Test...");
  
  try {
    // Step 1: Environment Check
    console.log("\n‚úÖ Step 1: Environment Check");
    if (!process.env.API_KEY && !process.env.GEMINI_API_KEY) {
      throw new Error("API_KEY or GEMINI_API_KEY missing in .env");
    }
    report.steps.envCheck = { status: 'SUCCESS', message: 'API key present' };
    console.log("   ‚úÖ Environment OK");

    // Step 2: Initialize Analyzer
    console.log("\n‚úÖ Step 2: Initialize Vulnerability Analyzer");
    const analyzer = new VulnerabilityAnalyzer();
    report.steps.analyzerInit = { status: 'SUCCESS', message: 'Analyzer initialized' };
    console.log("   ‚úÖ Analyzer initialized");

    // Step 3: Create Mock Data
    console.log("\n‚úÖ Step 3: Create Mock Test Data");
    const mockRepo = createMockRepository();
    const mockVulns = createMockVulnerabilities();
    report.steps.mockDataCreation = { 
      status: 'SUCCESS', 
      message: `Created mock repo (${mockRepo.fullName}) with ${mockVulns.length} vulnerabilities` 
    };
    console.log(`   ‚úÖ Created mock repository: ${mockRepo.fullName}`);
    console.log(`   ‚úÖ Created ${mockVulns.length} mock vulnerabilities`);

    // Step 4: Run Vulnerability Analysis
    console.log("\n‚úÖ Step 4: Run Vulnerability Analysis");
    console.log("   ‚è≥ Analyzing vulnerabilities (this may take a moment for AI analysis)...");
    
    const vulnerabilityReport = await analyzer.analyzeVulnerabilities(mockRepo, mockVulns);
    
    report.steps.vulnerabilityAnalysis = { 
      status: 'SUCCESS', 
      message: `Analysis completed: ${vulnerabilityReport.severity_level} (${vulnerabilityReport.severity_score}/10)` 
    };
    console.log(`   ‚úÖ Analysis completed`);
    console.log(`   üìä Severity: ${vulnerabilityReport.severity_level} (${vulnerabilityReport.severity_score}/10)`);
    console.log(`   üè∑Ô∏è  Tags: ${vulnerabilityReport.tags.join(', ')}`);
    console.log(`   üìù Summary length: ${vulnerabilityReport.summary.length} characters`);

    // Step 5: Validate Report
    console.log("\n‚úÖ Step 5: Validate Report Structure");
    const validationErrors: string[] = [];

    if (!vulnerabilityReport.id) validationErrors.push('Missing report ID');
    if (!vulnerabilityReport.repository) validationErrors.push('Missing repository');
    if (!Array.isArray(vulnerabilityReport.vulnerabilities)) validationErrors.push('Vulnerabilities must be array');
    if (typeof vulnerabilityReport.severity_score !== 'number') validationErrors.push('Severity score must be number');
    if (!['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'].includes(vulnerabilityReport.severity_level)) {
      validationErrors.push('Invalid severity level');
    }
    if (!vulnerabilityReport.summary) validationErrors.push('Missing summary');
    if (!Array.isArray(vulnerabilityReport.tags)) validationErrors.push('Tags must be array');
    if (!Array.isArray(vulnerabilityReport.references)) validationErrors.push('References must be array');
    if (!vulnerabilityReport.scanTimestamp) validationErrors.push('Missing scan timestamp');

    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    report.steps.reportValidation = { 
      status: 'SUCCESS', 
      message: 'Report structure validated successfully' 
    };
    console.log("   ‚úÖ Report structure is valid");

    // Display detailed report
    console.log("\nüìã Detailed Report:");
    console.log("   " + "=".repeat(60));
    console.log(`   Repository: ${vulnerabilityReport.repository.fullName}`);
    console.log(`   Stars: ${vulnerabilityReport.repository.stars} ‚≠ê`);
    console.log(`   Language: ${vulnerabilityReport.repository.language || 'Unknown'}`);
    console.log(`   Vulnerabilities Found: ${vulnerabilityReport.vulnerabilities.length}`);
    console.log(`   Severity: ${vulnerabilityReport.severity_level} (${vulnerabilityReport.severity_score}/10)`);
    console.log(`   Tags: ${vulnerabilityReport.tags.join(', ')}`);
    console.log(`   References: ${vulnerabilityReport.references.length}`);
    console.log("\n   Summary Preview:");
    console.log("   " + "-".repeat(60));
    const summaryPreview = vulnerabilityReport.summary.substring(0, 200);
    console.log(`   ${summaryPreview}...`);
    console.log("   " + "=".repeat(60));

    // Display vulnerabilities
    if (vulnerabilityReport.vulnerabilities.length > 0) {
      console.log("\nüîç Vulnerabilities:");
      vulnerabilityReport.vulnerabilities.forEach((vuln, idx) => {
        console.log(`\n   ${idx + 1}. ${vuln.queryName} (${vuln.severity.toUpperCase()})`);
        console.log(`      - File: ${vuln.filePath}:${vuln.startLine}`);
        console.log(`      - Rule: ${vuln.ruleId}`);
        console.log(`      - CWE: ${vuln.cwe || 'N/A'}`);
        console.log(`      - Message: ${vuln.message}`);
      });
    }

    report.status = 'SUCCESS';

  } catch (error: any) {
    console.error("\n‚ùå Test Failed:", error.message);
    report.status = 'FAILED';
    report.errors.push(error.message);
  } finally {
    saveReport();
  }
}

// Run test
runTest().catch(console.error);
