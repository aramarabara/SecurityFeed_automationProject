import fs from 'fs';
import path from 'path';
import dotenv from 'dotenv';
import { GitHubScanner } from '../services/scanner/githubScanner';
import { MockCodeQLRunner, CodeQLCLIRunner } from '../services/scanner/codeqlRunner';
import { VulnerabilityAnalyzer } from '../services/scanner/vulnerabilityAnalyzer';

// Initialize environment
dotenv.config();

// Load configuration
const config = JSON.parse(fs.readFileSync('automation.config.json', 'utf-8'));

// Ensure directories exist
const ensureDirs = () => {
  ['data/vulnerabilities', 'data/reports'].forEach(dir => {
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  });
};

// Generate date folder path (YYYY-MM-DD)
const getDateFolder = () => {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

// Generate descriptive filename for vulnerability reports
const generateReportFilename = (report) => {
  const severity = report.severity_level;
  const repoName = report.repository.name.replace(/[^a-zA-Z0-9-]/g, '-');
  const vulnCount = report.vulnerabilities.length;
  const idShort = report.id.substring(0, 8);
  return `${severity}_${repoName}_${vulnCount}vulns_${idShort}.json`;
};

// Save vulnerability report
const saveReport = (report) => {
  const dateFolder = getDateFolder();
  const fullPath = path.join('data/vulnerabilities', dateFolder);
  if (!fs.existsSync(fullPath)) {
    fs.mkdirSync(fullPath, { recursive: true });
  }
  
  const filename = generateReportFilename(report);
  const filePath = path.join(fullPath, filename);
  fs.writeFileSync(filePath, JSON.stringify(report, null, 2));
  console.log(`   üíæ Saved: ${filePath}`);
  return filePath;
};

// Extract keywords from analyzed articles
async function extractKeywordsFromArticles() {
  console.log("üìö [Step 1] Extracting keywords from analyzed articles...");
  
  const analyzedDir = 'data/analyzed';
  if (!fs.existsSync(analyzedDir)) {
    console.log("   ‚ö†Ô∏è No analyzed articles found. Using default keywords.");
    return ['authentication', 'crypto', 'security', 'encryption'];
  }

  const keywords = new Set();
  const dateFolder = getDateFolder();
  const todayDir = path.join(analyzedDir, dateFolder);
  
  // Try today's folder first, then fallback to any folder
  const searchDirs = fs.existsSync(todayDir) 
    ? [todayDir] 
    : fs.readdirSync(analyzedDir, { withFileTypes: true })
        .filter(d => d.isDirectory())
        .map(d => path.join(analyzedDir, d.name))
        .slice(-3); // Last 3 days

  for (const dir of searchDirs) {
    const files = fs.readdirSync(dir).filter(f => f.endsWith('.json'));
    for (const file of files.slice(0, 5)) { // Limit to 5 files per directory
      try {
        const content = JSON.parse(fs.readFileSync(path.join(dir, file), 'utf-8'));
        if (content.tags && Array.isArray(content.tags)) {
          content.tags.forEach(tag => keywords.add(tag.toLowerCase()));
        }
      } catch (e) {
        // Skip invalid files
      }
    }
  }

  // GitHub API allows max 5 OR operators, so limit to 5 keywords
  const keywordArray = Array.from(keywords).slice(0, 5);
  console.log(`   ‚úÖ Extracted ${keywordArray.length} keywords: ${keywordArray.join(', ')}`);
  
  return keywordArray.length > 0 
    ? keywordArray 
    : ['authentication', 'crypto', 'security', 'encryption']; // Fallback
}

// Main vulnerability scanning workflow
async function runVulnerabilityScan() {
  console.log("=== Vulnerability Scan Started ===");
  ensureDirs();

  try {
    // Step 1: Extract keywords from analyzed articles
    const keywords = await extractKeywordsFromArticles();

    // Step 2: Initialize scanner
    console.log("üîç [Step 2] Initializing GitHub Scanner...");
    const scanner = new GitHubScanner();
    
    // Check rate limit
    const rateLimit = await scanner.checkRateLimit();
    console.log(`   üìä GitHub API Rate Limit: ${rateLimit.remaining} remaining`);

    // Step 3: Search repositories
    console.log("üîé [Step 3] Searching GitHub repositories...");
    const scanConfig = config.vulnerability_scan || {};
    const githubConfig = scanConfig.github || {};
    
    const minStars = githubConfig.star_range?.[0] || 100;
    const maxStars = githubConfig.star_range?.[1] || 1000;
    const maxRepos = githubConfig.max_repos_per_scan || 10;

    // Only scan Python repositories (CodeQL build issues with Java/C++)
    const repositories = await scanner.searchRepositories(
      keywords,
      minStars,
      maxStars,
      'python', // Only Python repositories
      maxRepos
    );

    if (repositories.length === 0) {
      console.log("   ‚ö†Ô∏è No repositories found. Exiting.");
      return;
    }

    console.log(`   ‚úÖ Found ${repositories.length} repositories to scan`);

    // Step 4: Run CodeQL analysis
    console.log("üî¨ [Step 4] Running CodeQL analysis...");
    const codeqlConfig = scanConfig.codeql || {};
    const codeqlEnabled = codeqlConfig.enabled !== false; // Default to true
    const runnerType = codeqlConfig.runner_type || 'cli'; // 'mock' or 'cli'

    // Filter to only Python repositories
    const pythonRepos = repositories.filter(repo => 
      repo.language && repo.language.toLowerCase() === 'python'
    );

    if (pythonRepos.length === 0) {
      console.log("   ‚ö†Ô∏è No Python repositories found. Exiting.");
      return;
    }

    console.log(`   ‚úÖ Found ${pythonRepos.length} Python repositories (filtered from ${repositories.length} total)`);

    // Choose runner based on config
    const codeqlRunner = runnerType === 'mock' 
      ? new MockCodeQLRunner()
      : new CodeQLCLIRunner();
    const analyzer = new VulnerabilityAnalyzer();
    const reports = [];

    for (let i = 0; i < pythonRepos.length; i++) {
      const repo = pythonRepos[i];
      console.log(`\n   [${i + 1}/${pythonRepos.length}] Scanning: ${repo.fullName} (${repo.stars} ‚≠ê) [${repo.language}]`);
      
      try {
        // Skip if not Python
        if (repo.language?.toLowerCase() !== 'python') {
          console.log(`   ‚è≠Ô∏è  Skipping ${repo.language} repository (only Python supported)`);
          continue;
        }

        // Prepare repository (clone)
        const tempPath = path.join('data/temp_scan', repo.name);
        await codeqlRunner.prepareRepository(repo.cloneUrl, tempPath);

        // Create database
        const dbPath = await codeqlRunner.createDatabase(tempPath, 'python');

        // Run queries
        const vulnerabilities = await codeqlRunner.runQueries(dbPath, codeqlConfig.queries);

        // Generate detailed CodeQL report (with AST information)
        const sarifPath = path.join('data/temp_scan', `${repo.name}.sarif`);
        let detailedReport = null;
        
        // Try to get SARIF path from runner if available
        const actualSarifPath = (codeqlRunner as any).lastSarifPath || sarifPath;
        
        if (await fs.pathExists(actualSarifPath)) {
          try {
            console.log(`   üìä Generating detailed report with AST information...`);
            detailedReport = await codeqlRunner.generateDetailedReport(dbPath, actualSarifPath);
          } catch (e: any) {
            console.log(`   ‚ö†Ô∏è  Could not generate detailed report: ${e.message}`);
          }
        } else {
          console.log(`   ‚ö†Ô∏è  SARIF file not found at ${actualSarifPath}`);
        }

        // Analyze vulnerabilities
        const report = await analyzer.analyzeVulnerabilities(repo, vulnerabilities);
        
        // Add detailed report if available
        if (detailedReport) {
          report.detailedReport = detailedReport;
        }
        
        // Save report
        saveReport(report);
        
        // Save detailed CodeQL report separately
        if (detailedReport) {
          const dateFolder = getDateFolder();
          const detailedReportPath = path.join('data/vulnerabilities', dateFolder);
          if (!fs.existsSync(detailedReportPath)) {
            fs.mkdirSync(detailedReportPath, { recursive: true });
          }
          const detailedFilename = `DETAILED_${repo.name}_${report.id.substring(0, 8)}.json`;
          fs.writeFileSync(
            path.join(detailedReportPath, detailedFilename),
            JSON.stringify(detailedReport, null, 2)
          );
          console.log(`   üìÑ Detailed CodeQL report saved: ${detailedFilename}`);
        }
        
        reports.push(report);

        // Cleanup (mock: just simulates)
        await codeqlRunner.cleanup(tempPath);

        console.log(`   ‚úÖ Found ${vulnerabilities.length} vulnerability/vulnerabilities (Severity: ${report.severity_level})`);
      } catch (error) {
        console.error(`   ‚ùå Failed to scan ${repo.fullName}:`, error.message);
      }
    }

    // Step 5: Generate summary report
    console.log("\nüìä [Step 5] Generating summary report...");
    const dateFolder = getDateFolder();
    const summaryPath = path.join('data/reports', dateFolder);
    if (!fs.existsSync(summaryPath)) {
      fs.mkdirSync(summaryPath, { recursive: true });
    }

    const summary = {
      scanDate: new Date().toISOString(),
      totalRepositories: pythonRepos.length,
      scannedRepositories: reports.length,
      totalVulnerabilities: reports.reduce((sum, r) => sum + r.vulnerabilities.length, 0),
      severityBreakdown: {
        CRITICAL: reports.filter(r => r.severity_level === 'CRITICAL').length,
        HIGH: reports.filter(r => r.severity_level === 'HIGH').length,
        MEDIUM: reports.filter(r => r.severity_level === 'MEDIUM').length,
        LOW: reports.filter(r => r.severity_level === 'LOW').length,
        INFO: reports.filter(r => r.severity_level === 'INFO').length,
      },
      repositories: reports.map(r => ({
        name: r.repository.fullName,
        stars: r.repository.stars,
        language: r.repository.language,
        vulnerabilityCount: r.vulnerabilities.length,
        severity: r.severity_level,
        reportId: r.id,
      })),
      codeqlRunner: runnerType,
    };

    const summaryFile = path.join(summaryPath, `vulnerability-summary-${Date.now()}.json`);
    fs.writeFileSync(summaryFile, JSON.stringify(summary, null, 2));
    console.log(`   ‚úÖ Summary saved: ${summaryFile}`);

    console.log("\n=== Vulnerability Scan Completed ===");
    console.log(`üìà Summary: ${summary.totalVulnerabilities} vulnerabilities found across ${summary.totalRepositories} repositories`);

  } catch (error) {
    console.error("‚ùå Vulnerability scan failed:", error);
    process.exit(1);
  }
}

// Run if executed directly
runVulnerabilityScan().catch(console.error);

export { runVulnerabilityScan };
