import fs from 'fs';
import path from 'path';
import { CodeQLCLIRunner } from '../services/scanner/codeqlRunner';
import dotenv from 'dotenv';

dotenv.config();

/**
 * Generate detailed CodeQL report from existing SARIF files
 * NOW ALSO produces human-readable markdown report as a sibling file.
 * Usage: tsx scripts/generate_detailed_report.ts [repo-name]
 */
async function generateReportFromSarif() {
  const repoName = process.argv[2];
  
  if (!repoName) {
    console.log("Usage: tsx scripts/generate_detailed_report.ts <repo-name>");
    console.log("\nAvailable SARIF files:");
    const tempDir = 'data/temp_scan';
    if (fs.existsSync(tempDir)) {
      const files = fs.readdirSync(tempDir).filter(f => f.endsWith('.sarif'));
      files.forEach(f => console.log(`  - ${f.replace('.sarif', '')}`));
    }
    process.exit(1);
  }

  const tempDir = 'data/temp_scan';
  const sarifPath = path.join(tempDir, `${repoName}.sarif`);
  const dbPath = path.join(tempDir, `${repoName}-db`);

  if (!fs.existsSync(sarifPath)) {
    console.error(`âŒ SARIF file not found: ${sarifPath}`);
    process.exit(1);
  }

  if (!fs.existsSync(dbPath)) {
    console.error(`âŒ Database not found: ${dbPath}`);
    console.log("Note: Database may have been cleaned up. Re-run scan to generate report.");
    process.exit(1);
  }

  console.log(`ðŸ“Š Generating detailed CodeQL report for ${repoName}...`);
  console.log(`   SARIF: ${sarifPath}`);
  console.log(`   Database: ${dbPath}`);

  const runner = new CodeQLCLIRunner();
  
  try {
    const detailedReport = await runner.generateDetailedReport(dbPath, sarifPath);
    // Save detailed report (JSON)
    const dateFolder = new Date().toISOString().split('T')[0].replace(/-/g, '-');
    const reportDir = path.join('data/vulnerabilities', dateFolder);
    if (!fs.existsSync(reportDir)) {
      fs.mkdirSync(reportDir, { recursive: true });
    }
    const reportFile = path.join(reportDir, `DETAILED_${repoName}_${Date.now()}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(detailedReport, null, 2));

    // --- Additional: Also create human-readable Markdown report ---
    const markdown = generateMarkdownReport(detailedReport, repoName);
    const mdOutput = reportFile.replace('.json', '_REPORT.md');
    fs.writeFileSync(mdOutput, markdown);

    // CLI output summarization
    console.log(`\nâœ… Detailed report saved: ${reportFile}`);
    console.log(`âœ… Human-readable report saved: ${mdOutput}`);
    console.log(`\nðŸ“‹ Report Summary:`);
    console.log(`   - Database Language: ${detailedReport.databaseInfo.language}`);
    console.log(`   - Total Files: ${detailedReport.statistics.totalFiles}`);
    console.log(`   - Lines of Code: ${detailedReport.statistics.totalLinesOfCode}`);
    console.log(`   - Lines of User Code: ${detailedReport.statistics.totalLinesOfUserCode}`);
    console.log(`   - Total Queries: ${detailedReport.queryResults.totalQueries}`);
    console.log(`   - Total Results: ${detailedReport.sarifResults.totalResults}`);
    console.log(`   - Code Flows (AST paths): ${detailedReport.codeFlows?.length || 0}`);
    if (detailedReport.codeFlows && detailedReport.codeFlows.length > 0) {
      console.log(`\nðŸ” AST Code Flows Found:`);
      detailedReport.codeFlows.forEach((flow, idx) => {
        console.log(`   ${idx + 1}. ${flow.ruleId}`);
        console.log(`      Message: ${flow.message.substring(0, 60)}...`);
        console.log(`      Flow paths: ${flow.flows.length}`);
      });
    }
    console.log(`\nðŸ’¡ Full AST information is available in:`);
    console.log(`   - databaseInfo.creationMetadata (extraction metadata)`);
    console.log(`   - codeFlows (AST traversal paths for each vulnerability)`);
    console.log(`   - rawSarif (complete SARIF with all AST node information)`);
  } catch (error: any) {
    console.error(`âŒ Failed to generate report: ${error.message}`);
    process.exit(1);
  }
}

// --- Markdown generator (from former generate_human_readable_report.ts) ---

function generateMarkdownReport(report, repoName: string): string {
  const md: string[] = [];
  // Header
  md.push(`# CodeQL Security Analysis Report`);
  md.push(`\n**Repository**: ${repoName}`);
  md.push(`\n**Analysis Date**: ${new Date().toISOString().split('T')[0]}`);
  md.push(`\n**Language**: ${report.databaseInfo.language}`);
  md.push(`\n---\n`);
  // Executive Summary
  md.push(`## ðŸ“Š Executive Summary\n`);
  md.push(`- **Total Files Analyzed**: ${report.statistics.totalFiles}`);
  md.push(`- **Lines of Code**: ${report.statistics.totalLinesOfCode || 'N/A'}`);
  md.push(`- **Lines of User Code**: ${report.statistics.totalLinesOfUserCode || 'N/A'}`);
  md.push(`- **Total Queries Executed**: ${report.queryResults.totalQueries}`);
  md.push(`- **Vulnerabilities Found**: ${report.sarifResults.totalResults}`);
  md.push(`  - ðŸ”´ Critical (error): ${report.sarifResults.resultsBySeverity.error}`);
  md.push(`  - ðŸŸ  Warning: ${report.sarifResults.resultsBySeverity.warning}`);
  md.push(`  - ðŸ”µ Note: ${report.sarifResults.resultsBySeverity.note}`);
  md.push(`\n---\n`);
  // Database Information
  md.push(`## ðŸ—„ï¸ Database Information\n`);
  md.push(`- **Language**: ${report.databaseInfo.language}`);
  md.push(`- **Source Location**: ${report.databaseInfo.sourceLocation}`);
  md.push(`- **Database Version**: ${report.databaseInfo.databaseVersion}`);
  if (report.databaseInfo.creationMetadata) {
    md.push(`\n### Creation Metadata\n`);
    md.push("```json");
    md.push(JSON.stringify(report.databaseInfo.creationMetadata, null, 2));
    md.push("```");
  }
  md.push(`\n---\n`);
  // Statistics
  md.push(`## ðŸ“ˆ Code Statistics\n`);
  md.push(`### Extracted Files (${report.statistics.extractedFiles.length})\n`);
  report.statistics.extractedFiles.forEach((file, idx) => {
    md.push(`${idx + 1}. \`${file}\``);
  });
  md.push(`\n---\n`);
  // Query Results
  md.push(`## ðŸ” Query Results\n`);
  md.push(`### Executed Queries (${report.queryResults.queriesExecuted.length})\n`);
  report.queryResults.queriesExecuted.forEach((query, idx) => {
    const count = report.queryResults.resultsByQuery[query] || 0;
    const icon = count > 0 ? 'ðŸ”´' : 'âœ…';
    md.push(`${idx + 1}. ${icon} \`${query}\` - ${count} result(s)`);
  });
  md.push(`\n---\n`);
  // Code Flows (AST Information)
  if (report.codeFlows && report.codeFlows.length > 0) {
    md.push(`## ðŸŒ³ AST Code Flows (Data Flow Analysis)\n`);
    md.push(`\nThis section shows the AST traversal paths for each vulnerability, demonstrating how data flows through the code.\n`);
    report.codeFlows.forEach((flow, idx) => {
      md.push(`\n### ${idx + 1}. ${flow.ruleId}\n`);
      md.push(`**Message**: ${flow.message.substring(0, 100)}${flow.message.length > 100 ? '...' : ''}\n`);
      flow.flows.forEach((f, flowIdx) => {
        md.push(`\n#### Flow Path ${flowIdx + 1}\n`);
        f.threadFlows.forEach((tf, tfIdx) => {
          md.push(`\n**Thread Flow ${tfIdx + 1}**:\n`);
          md.push(`\n| Step | File | Line | Column | AST Node |`);
          md.push(`|------|------|------|--------|---------|`);
          tf.locations.forEach((loc, locIdx) => {
            md.push(`| ${locIdx + 1} | \`${loc.file}\` | ${loc.line} | ${loc.column} | ${loc.message || loc.kind || 'N/A'} |`);
          });
        });
      });
    });
    md.push(`\n---\n`);
  }
  // SARIF Results Summary
  md.push(`## ðŸš¨ Vulnerability Summary\n`);
  md.push(`\n### By Severity\n`);
  md.push(`- **Error**: ${report.sarifResults.resultsBySeverity.error}`);
  md.push(`- **Warning**: ${report.sarifResults.resultsBySeverity.warning}`);
  md.push(`- **Note**: ${report.sarifResults.resultsBySeverity.note}`);
  md.push(`\n### By Query Type\n`);
  Object.entries(report.queryResults.resultsByQuery)
    .sort(([, a], [, b]) => b - a)
    .forEach(([query, count]) => {
      md.push(`- \`${query}\`: ${count} result(s)`);
    });
  md.push(`\n---\n`);
  // Raw SARIF Reference
  md.push(`## ðŸ“Ž Additional Information\n`);
  md.push(`\nThis report is generated from CodeQL analysis results. For complete details including:`);
  md.push(`- Full AST node information`);
  md.push(`- Complete code flow paths`);
  md.push(`- All SARIF metadata`);
  md.push(`\nPlease refer to the \`rawSarif\` field in the original JSON file.\n`);
  md.push(`\n---\n`);
  md.push(`\n*Generated by SecurityFeed AI - CodeQL Analysis System*`);

  return md.join('\n');
}

// Entry
generateReportFromSarif();
