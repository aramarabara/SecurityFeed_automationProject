import { GitHubRepository, CodeQLVulnerability, VulnerabilityReport } from '../../models/vulnerability';
import { AIAgent } from '../processor/aiAgent';
import { RawArticle } from '../../models/schema';

export class VulnerabilityAnalyzer {
  private aiAgent: AIAgent;

  constructor() {
    this.aiAgent = new AIAgent();
  }

  /**
   * Analyze CodeQL vulnerabilities and generate comprehensive report
   */
  async analyzeVulnerabilities(
    repository: GitHubRepository,
    vulnerabilities: CodeQLVulnerability[]
  ): Promise<VulnerabilityReport> {
    if (vulnerabilities.length === 0) {
      return this.createEmptyReport(repository);
    }

    // Create a synthetic article from vulnerability data for AI analysis
    const vulnerabilitySummary = this.createVulnerabilitySummary(repository, vulnerabilities);
    const syntheticArticle: RawArticle = {
      id: `vuln-${repository.id}-${Date.now()}`,
      title: `Security Vulnerabilities Found in ${repository.fullName}`,
      url: repository.url,
      content: vulnerabilitySummary,
      source: 'CodeQL Scan',
      timestamp: new Date().toISOString(),
    };

    // Use AI to analyze vulnerabilities
    const analyzed = await this.aiAgent.analyze(syntheticArticle);

    // Map CodeQL severity to our severity levels
    const maxCodeQLSeverity = this.getMaxCodeQLSeverity(vulnerabilities);
    const severityScore = this.calculateSeverityScore(vulnerabilities, maxCodeQLSeverity, analyzed.severity_score);

    return {
      id: `report-${repository.id}-${Date.now()}`,
      repository,
      vulnerabilities,
      severity_score: severityScore,
      severity_level: analyzed.severity_level,
      summary: analyzed.summary,
      tags: [...analyzed.tags, ...this.extractVulnerabilityTags(vulnerabilities)],
      references: [
        ...analyzed.references || [],
        ...this.generateVulnerabilityReferences(vulnerabilities),
      ],
      scanTimestamp: new Date().toISOString(),
      codeqlVersion: 'mock-1.0.0', // Will be replaced with actual version when CLI is integrated
    };
  }

  private createVulnerabilitySummary(
    repository: GitHubRepository,
    vulnerabilities: CodeQLVulnerability[]
  ): string {
    const vulnCount = vulnerabilities.length;
    const errorCount = vulnerabilities.filter(v => v.severity === 'error').length;
    const warningCount = vulnerabilities.filter(v => v.severity === 'warning').length;
    const cweList = [...new Set(vulnerabilities.map(v => v.cwe).filter(Boolean))];

    return `
Repository: ${repository.fullName}
Stars: ${repository.stars}
Language: ${repository.language || 'Unknown'}
Description: ${repository.description || 'N/A'}

Vulnerability Summary:
- Total vulnerabilities found: ${vulnCount}
- Critical (error): ${errorCount}
- Warnings: ${warningCount}
- CWE IDs: ${cweList.join(', ') || 'N/A'}

Detailed Findings:
${vulnerabilities.map((v, idx) => `
${idx + 1}. ${v.queryName} (${v.severity.toUpperCase()})
   - File: ${v.filePath}:${v.startLine}
   - Rule: ${v.ruleId}
   - CWE: ${v.cwe || 'N/A'}
   - Message: ${v.message}
   - Code: ${v.codeSnippet}
`).join('\n')}
    `.trim();
  }

  private getMaxCodeQLSeverity(vulnerabilities: CodeQLVulnerability[]): 'error' | 'warning' | 'note' {
    if (vulnerabilities.some(v => v.severity === 'error')) return 'error';
    if (vulnerabilities.some(v => v.severity === 'warning')) return 'warning';
    return 'note';
  }

  private calculateSeverityScore(
    vulnerabilities: CodeQLVulnerability[],
    maxSeverity: string,
    aiScore: number
  ): number {
    // Base score from AI analysis
    let score = aiScore;

    // Adjust based on CodeQL severity
    if (maxSeverity === 'error') {
      score = Math.min(10, score + 2);
    } else if (maxSeverity === 'warning') {
      score = Math.min(10, score + 1);
    }

    // Adjust based on number of vulnerabilities
    const vulnCount = vulnerabilities.length;
    if (vulnCount >= 5) {
      score = Math.min(10, score + 1);
    } else if (vulnCount >= 10) {
      score = Math.min(10, score + 2);
    }

    return Math.round(score * 10) / 10; // Round to 1 decimal
  }

  private extractVulnerabilityTags(vulnerabilities: CodeQLVulnerability[]): string[] {
    const tags = new Set<string>();
    
    vulnerabilities.forEach(v => {
      // Extract from rule ID
      if (v.ruleId.includes('sql')) tags.add('SQL Injection');
      if (v.ruleId.includes('xss')) tags.add('XSS');
      if (v.ruleId.includes('credential')) tags.add('Hardcoded Credentials');
      if (v.ruleId.includes('injection')) tags.add('Injection');
      
      // Extract from CWE
      if (v.cwe) {
        if (v.cwe.includes('89')) tags.add('SQL Injection');
        if (v.cwe.includes('79')) tags.add('XSS');
        if (v.cwe.includes('798')) tags.add('Hardcoded Credentials');
      }
    });

    return Array.from(tags);
  }

  private generateVulnerabilityReferences(vulnerabilities: CodeQLVulnerability[]): string[] {
    const references = new Set<string>();

    vulnerabilities.forEach(v => {
      if (v.cwe) {
        references.add(`CWE-${v.cwe}: ${this.getCWEDescription(v.cwe)}`);
      }
      references.add(`CodeQL Query: ${v.queryName} (${v.ruleId})`);
    });

    return Array.from(references);
  }

  private getCWEDescription(cwe: string): string {
    const cweMap: Record<string, string> = {
      '89': 'SQL Injection',
      '79': 'Cross-site Scripting (XSS)',
      '798': 'Use of Hard-coded Credentials',
      '20': 'Improper Input Validation',
      '22': 'Path Traversal',
    };
    return cweMap[cwe] || 'Common Weakness Enumeration';
  }

  private createEmptyReport(repository: GitHubRepository): VulnerabilityReport {
    return {
      id: `report-${repository.id}-${Date.now()}`,
      repository,
      vulnerabilities: [],
      severity_score: 0,
      severity_level: 'INFO',
      summary: `No security vulnerabilities detected in ${repository.fullName} using CodeQL analysis.`,
      tags: ['No Vulnerabilities'],
      references: [],
      scanTimestamp: new Date().toISOString(),
    };
  }
}
